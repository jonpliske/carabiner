// Generated by CoffeeScript 2.0.0-beta6
void function () {
  var async, fs, path, splunkjs, Table, util;
  path = require('path');
  fs = require('fs');
  util = require('util');
  async = require('async');
  splunkjs = require('splunk-sdk');
  Table = require('cli-table');
  module.exports = function () {
    var args, defaults, fetchJob, fetchResults, hookSignals, monitorSearch, noErr, omit, options, performSearch, processArgs, readDefaults, searchStats, splunk;
    processArgs = function (argv) {
      var args, options, potentialFilename;
      args = argv.slice(2);
      options = {};
      options.table = in$('--table', args);
      potentialFilename = args.slice(-1)[0];
      if (potentialFilename && fs.existsSync(potentialFilename))
        options.query = fs.readFileSync(potentialFilename).toString();
      return options;
    };
    readDefaults = function (path) {
      var defaults, key, line, lines, parts, val;
      defaults = {};
      lines = fs.readFileSync(path, 'utf8').split('\n');
      for (var i$ = 0, length$ = lines.length; i$ < length$; ++i$) {
        line = lines[i$];
        line = line.trim();
        if (line !== '' && line[0] !== '#') {
          parts = line.split('=');
          key = parts[0].trim();
          val = parts[1].trim();
          defaults[key] = val;
        }
      }
      return defaults;
    };
    defaults = function () {
      var defaultsPath;
      defaultsPath = path.join(process.env.HOME, '.splunkrc');
      if (fs.existsSync(defaultsPath)) {
        return readDefaults(defaultsPath);
      } else {
        throw new Error('no defaults');
      }
    };
    omit = function (obj) {
      var copy, key, keys, val;
      copy = {};
      keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
      for (key in obj) {
        val = obj[key];
        if (!in$(key, keys))
          copy[key] = val;
      }
      return copy;
    };
    args = processArgs(process.argv);
    options = defaults();
    options.table = args.table;
    options.query = args.query;
    searchStats = function (job, cb) {
      var cache$, diskUsage, eventCount, eventSearch, priority, runDuration;
      if (!(null != job))
        cb(new Error('no job'));
      cache$ = job.properties();
      eventCount = cache$.eventCount;
      diskUsage = cache$.diskUsage;
      priority = cache$.priority;
      runDuration = cache$.runDuration;
      eventSearch = cache$.eventSearch;
      console.log('\n');
      console.log('### JOB statistics');
      console.log('#');
      console.log('#    duration: ' + runDuration + 's');
      console.log('#    eventCount: ' + eventCount);
      console.log('#    diskUsage: ' + diskUsage / 1024 + ' KB');
      console.log('#    priority: ' + priority);
      console.log('#');
      console.log('#    search:');
      console.log('#      ' + options.query);
      console.log('#');
      console.log('###');
      console.log('\n');
      return cb(noErr, job);
    };
    fetchJob = function (job, cb) {
      return job.fetch(cb);
    };
    hookSignals = function (job, cb) {
      process.on('SIGINT', function () {
        console.log('Recieved SIGINT: cancelling job');
        return job.cancel(function (err) {
          if (null != err)
            cb(err);
          console.log('-- search canceled --');
          return process.exit();
        });
      });
      return cb(noErr, job);
    };
    performSearch = function (searchString) {
      return function (loggedIn, cb) {
        if (!loggedIn)
          throw new Error('login failed');
        return splunk.search(searchString, {}, cb);
      };
    };
    monitorSearch = function (job, cb) {
      var count, jobUrl;
      count = 0;
      jobUrl = options.scheme + '://' + options.host + ':' + options.port + job.qualifiedPath;
      console.log('');
      console.log('-- search running: ' + jobUrl);
      return async.until(function () {
        return job.properties().isDone;
      }, function (done) {
        return job.fetch(function (err) {
          var newCount;
          if (null != err)
            done(err);
          newCount = job.properties().eventCount;
          if (newCount > count) {
            console.log('-- in progress, ' + count + ' events');
            count = newCount;
          }
          return done();
        });
      }, function (err) {
        if (null != err)
          cb(err);
        console.log('-- search complete --');
        return cb(noErr, job);
      });
    };
    fetchResults = function (job, cb) {
      return job.results({}, cb);
    };
    splunk = new splunkjs.Service({
      scheme: options.scheme,
      host: options.host,
      port: options.port,
      username: options.username,
      password: options.password,
      version: options.version
    });
    async.waterfall([
      splunk.login,
      performSearch(options.query),
      fetchJob,
      hookSignals,
      monitorSearch,
      searchStats,
      fetchResults
    ], function (err, results) {
      var cache$, fields, row, rows, table;
      if (null != err) {
        console.log(err);
        throw err;
      }
      if (options.table) {
        cache$ = results;
        fields = cache$.fields;
        rows = cache$.rows;
        table = new Table({ head: fields });
        for (var i$ = 0, length$ = rows.length; i$ < length$; ++i$) {
          row = rows[i$];
          table.push(row);
        }
        return console.log(table.toString());
      } else {
        return console.log(results);
      }
    });
    return noErr = null;
  };
  function in$(member, list) {
    for (var i = 0, length = list.length; i < length; ++i)
      if (i in list && list[i] === member)
        return true;
    return false;
  }
}.call(this);
